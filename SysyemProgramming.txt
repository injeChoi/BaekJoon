import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.Iterator;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Array;
import java.util.StringTokenizer;


/**
 * Assembler :
 * 이 프로그램은 SIC/XE 머신을 위한 Assembler 프로그램의 메인 루틴이다.
 * 프로그램의 수행 작업은 다음과 같다.
 * 1) 처음 시작하면 Instruction 명세를 읽어들여서 assembler를 세팅한다.
 * 2) 사용자가 작성한 input 파일을 읽어들인 후 저장한다.
 * 3) input 파일의 문장들을 단어별로 분할하고 의미를 파악해서 정리한다. (pass1)
 * 4) 분석된 내용을 바탕으로 컴퓨터가 사용할 수 있는 object code를 생성한다. (pass2)
 *
 *
 * 작성중의 유의사항 :
 *  1) 새로운 클래스, 새로운 변수, 새로운 함수 선언은 얼마든지 허용됨. 단, 기존의 변수와 함수들을 삭제하거나 완전히 대체하는 것은 안된다.
 *  2) 마찬가지로 작성된 코드를 삭제하지 않으면 필요에 따라 예외처리, 인터페이스 또는 상속 사용 또한 허용됨.
 *  3) 모든 void 타입의 리턴값은 유저의 필요에 따라 다른 리턴 타입으로 변경 가능.
 *  4) 파일, 또는 콘솔창에 한글을 출력시키지 말 것. (채점상의 이유. 주석에 포함된 한글은 상관 없음)
 *
 *
 *  + 제공하는 프로그램 구조의 개선방법을 제안하고 싶은 분들은 보고서의 결론 뒷부분에 첨부 바랍니다. 내용에 따라 가산점이 있을 수 있습니다.
 */
public class Assembler {
	/** instruction 명세를 저장한 공간 */
	InstTable instTable;
	/** 읽어들인 input 파일의 내용을 한 줄 씩 저장하는 공간. */
	ArrayList<String> lineList;
	/** 프로그램의 section별로 symbol table을 저장하는 공간*/
	ArrayList<SymbolTable> symtabList;
	/** 프로그램의 section별로 literal table을 저장하는 공간*/
	ArrayList<LiteralTable> literaltabList;
	/** 프로그램의 section별로 프로그램을 저장하는 공간*/
	ArrayList<TokenTable> TokenList;
	/**
	 * Token, 또는 지시어에 따라 만들어진 오브젝트 코드들을 출력 형태로 저장하는 공간.
	 * 필요한 경우 String 대신 별도의 클래스를 선언하여 ArrayList를 교체해도 무방함.
	 */
	ArrayList<String> codeList;

	static String[] section_len = new String[3];
	static int locctr = 0;
	static char register_number[] = { 'A', 'X', ' ', ' ', 'S', 'T' };

	/**
	 * 클래스 초기화. instruction Table을 초기화와 동시에 세팅한다.
	 *
	 * @param instFile : instruction 명세를 작성한 파일 이름.
	 */
	public Assembler(String instFile) {
		instTable = new InstTable(instFile);
		lineList = new ArrayList<String>();
		symtabList = new ArrayList<SymbolTable>();
		literaltabList = new ArrayList<LiteralTable>();
		TokenList = new ArrayList<TokenTable>();
		codeList = new ArrayList<String>();
	}

	/**
	 * 어셈블러의 메인 루틴
	 */
	public static void main(String[] args) {
		Assembler assembler = new Assembler("inst.data");
		assembler.loadInputFile("input.txt");
		assembler.pass1();

		assembler.printSymbolTable("symtab_20150287");
		assembler.printLiteralTable("literaltab_20150287");
		assembler.pass2();
		assembler.printObjectCode("output_20150287");
		System.out.println("File Write Complete, Please check project folder");
	}

	/**
	 * inputFile을 읽어들여서 lineList에 저장한다.
	 * @param inputFile : input 파일 이름.
	 */
	private void loadInputFile(String inputFile) {
		try {
			File input_f = new File("./src/input.txt");
			FileReader filereader = new FileReader(input_f);
			BufferedReader bufReader = new BufferedReader(filereader);
			String s = "";
			while ((s = bufReader.readLine()) != null) {
				if (s.equals("") || s.charAt(0) == '.')
					continue;
				lineList.add(s);
			}
		} catch (FileNotFoundException e) {
			System.out.println("input.txt is not exist");
			e.printStackTrace();
		} catch (IOException e) {
			System.out.println("input buffer is not exist");
			e.printStackTrace();
		}
	}

	/**
	 * pass1 과정을 수행한다.
	 *   1) 프로그램 소스를 스캔하여 토큰단위로 분리한 뒤 토큰테이블 생성
	 *   2) label을 symbolTable에 정리
	 *
	 *    주의사항 : SymbolTable과 TokenTable은 프로그램의 section별로 하나씩 선언되어야 한다.
	 */

	private void pass1() {
		// Table 초기화
		SymbolTable symTab = new SymbolTable();
		LiteralTable literalTab = new LiteralTable();
		TokenTable tokenTab = new TokenTable(symTab, literalTab, instTable);

		// lineList에 있는 데이터들을 한 줄 씩 token parsing시키는 과정, CSECT, END를 만나면 섹션 분할
		for(int i = 0; i < lineList.size(); i++) {
			String line = "";
			line = lineList.get(i);
			String[] split = line.split("\t");

			if(split[1].equals("CSECT")) {
				tokenTab.putToken(line);
				TokenList.add(tokenTab);
				tokenTab = new TokenTable(symTab, literalTab, instTable);
			}
			else if(split[1].equals("END")) {
				tokenTab.putToken(line);
				TokenList.add(tokenTab);
			}
			else
				tokenTab.putToken(line);
		}


		int location_plus = 0;
		int start_ads = 0;
		int s_len = 0;

		for(TokenTable tokenListIndex : TokenList) {	//TokenList 하나씩 진행
			for(int t_index = 0; t_index < tokenListIndex.tokenList.size(); t_index++) {
				Token t_line = tokenListIndex.getToken(t_index);

				if(t_line.operator.equals("START")) {
					start_ads = 0;
					locctr += start_ads;
					t_line.location = locctr;
					t_line.byteSize = 0;
					symTab.putSymbol(t_line.label, locctr);
					continue;
				}

				if(!(t_line.label.equals(""))) {
					if(t_line.operator.equals("CSECT")) {
						location_plus = 0;
						t_line.byteSize = 0;
						section_len[s_len++] = Integer.toHexString(locctr).toUpperCase();//section의 길이를 저장
						locctr = 0;
						symtabList.add(symTab);		//symtabList에 객체 넣기
						tokenListIndex.symTab = symTab;
						symTab = new SymbolTable();	//다음 섹션에서 나올 symbol들만 저장할 객체 생성
						continue;
					}
					else if(t_line.operator.equals("EQU")) {
						location_plus = 0;
						t_line.byteSize = 0;
						symTab.putSymbol(t_line.label, equ(t_line.operand[0], locctr, symTab));
					}
					else
						symTab.putSymbol(t_line.label, locctr);
				}
				//inst table에 있는 operator면 형식에 맞게 값 증가
				if(instTable.instMap.containsKey(t_line.operator)) {
					Instruction inst = instTable.instMap.get(t_line.operator);
					location_plus = inst.format;
					t_line.byteSize = inst.format;
					t_line.location = locctr;
				}
				//inst table에 없는 operator일 경우 유형에 맞게 처리
				else if(t_line.operator.charAt(0) == '+') {
					t_line.location = locctr;
					location_plus = 4;
					t_line.byteSize = 4;
				}
				else if(t_line.operator.equals("WORD")) {
					t_line.location = locctr;
					location_plus = 3;
					t_line.byteSize = 3;
					t_line.objectCode = "0";
				}
				else if(t_line.operator.equals("RESW")) {
					t_line.location = locctr;
					location_plus = Integer.parseInt(t_line.operand[0]) * 3;
					t_line.byteSize = Integer.parseInt(t_line.operand[0]) * 3;
				}
				else if(t_line.operator.equals("RESB")) {
					t_line.location = locctr;
					location_plus = Integer.parseInt(t_line.operand[0]);
					t_line.byteSize = Integer.parseInt(t_line.operand[0]);
				}
				else if(t_line.operator.equals("BYTE")) {
					t_line.location = locctr;
					location_plus = cal_Byte(t_line.operand[0]);
					t_line.byteSize = cal_Byte(t_line.operand[0]);
					String buffer;
					buffer = t_line.operand[0].substring(2, t_line.operand[0].length() - 1);
					t_line.objectCode = buffer;
				}
				else if(t_line.operator.equals("EXTDEF")) {
					location_plus = 0;
					t_line.byteSize = 0;
				}
				else if(t_line.operator.equals("EXTREF")) {
					location_plus = 0;
					t_line.byteSize = 0;
				}
				else if(t_line.operator.equals("LTORG")) {
					ltorg(t_index, locctr, tokenListIndex, literalTab);
					literaltabList.add(literalTab);
					literalTab = new LiteralTable();
				}
				else if(t_line.operator.equals("END")) {
					locctr = ltorg(t_index, locctr, TokenList.get(2), literalTab);
					section_len[s_len++] = Integer.toHexString(locctr).toUpperCase();//section의 길이를 저장
					symtabList.add(symTab);		//symtabList에 객체 넣기
					literaltabList.add(literalTab);
					tokenListIndex.symTab = symTab;
					tokenListIndex.literalTab = literalTab;
				}
				locctr += location_plus;
				t_line.pc = locctr;
			}
		}
	}

	//Literal 처리를 위한 함수, Literal Table을 조사해보고 새로운 Literal이면 추가한다
	public int ltorg(int idx, int locctr, TokenTable t, LiteralTable literalTab) {
		for(int t_index = 0; t_index < idx; t_index++) {
			Token t_line = t.getToken(t_index);

			if(t_line.operand[0].equals("")) {
				continue;
			}
			else {
				if(t_line.operand[0].substring(0, 1).equals("=")) {
					int check = 0;
					String sub_lit = t_line.operand[0].substring(3, t_line.operand[0].length()-1);
					if(literalTab.literalList.contains(sub_lit)) {
						check = 1;
						break;
					}

					if(check != 1) {
						literalTab.putLiteral(sub_lit, locctr);
						locctr += cal_Byte(t_line.operand[0]);
					}
				}
			}
		}
		return locctr;
 	}

	//EQU함수, operand와 연산자를 이용하여 주소 계산을 한다
	public int equ(String line, int locctr, SymbolTable symTab) {
		if(line.charAt(0) == '*') {
			return locctr;
		}
		else// 빼기만 구현
		{
			int tmp1 = 0;
			int tmp2 = 0;
			String split[] = line.split("-");
			if (split.length != 2) {
				System.out.println("operand != 2");
				return -1;
			}

			if(!(split[0].equals(""))) {
				for(int i = 0; i < symTab.symbolList.size(); i++) {
					String s = symTab.symbolList.get(i);

					if(s.equals(split[0])) {
						tmp1 = symTab.locationList.get(i);
						break;
					}
				}
			}

			if(!(split[1].equals(""))) {
				for(int i = 0; i < symTab.symbolList.size(); i++) {
					String s = symTab.symbolList.get(i);

					if(s.equals(split[1])) {
						tmp2 = symTab.locationList.get(i);
						break;
					}
				}
			}

			return tmp1-tmp2;
		}
	}

	public int cal_Byte(String str) {
		double size = 0.0;
		if (str.charAt(0) == '=')
			str = str.substring(1);

		if (str.charAt(0) == 'C')
			for (int i = 1; i < str.length(); ++i) {
				if (str.charAt(i) != 39)
					size += 1.0;
			}
		else
			for (int i = 1; i < str.length(); ++i) {
				if (str.charAt(i) != 39)
					size += 0.5;
			}

		return (int)size;
	}

	/**
	 * 작성된 SymbolTable들을 출력형태에 맞게 출력한다.
	 * @param fileName : 저장되는 파일 이름
	 */
	private void printSymbolTable(String fileName) {
		// TODO Auto-generated method stub
		try {
			File fp = new File(fileName);
			// BufferedWriter 사용
			BufferedWriter bw = new BufferedWriter(new FileWriter(fp));

			for(SymbolTable s : symtabList) {
				for(int i = 0; i < s.symbolList.size(); i++) {
					bw.write(s.symbolList.get(i) + "	" + Integer.toHexString(s.locationList.get(i)).toUpperCase() + "\n");
				}
				bw.newLine();
			}
			// 파일안에 문자열 쓰기
			bw.flush();
			bw.close();
		}
		catch (Exception e) {
			e.printStackTrace();
		}

//		if(fileName.equals("symtab_20150287")) {
//			for(SymbolTable s : symtabList) {
//				for(int i = 0; i < s.symbolList.size(); i++) {
//					System.out.println(s.symbolList.get(i) + "	" + Integer.toHexString(s.locationList.get(i)).toUpperCase());
//				}
//				System.out.println();
//			}
//		}
	}

	/**
	 * 작성된 LiteralTable들을 출력형태에 맞게 출력한다.
	 * @param fileName : 저장되는 파일 이름
	 */
	private void printLiteralTable(String fileName) {
		// TODO Auto-generated method stub
		try {
			File fp = new File(fileName);
			// BufferedWriter 사용
			BufferedWriter lw = new BufferedWriter(new FileWriter(fp));

			for(LiteralTable l : literaltabList) {
				for(int i = 0; i < l.literalList.size(); i++) {
					lw.write(l.literalList.get(i) + "	" + Integer.toHexString(l.locationList.get(i)).toUpperCase() + "\n");
				}
				lw.newLine();
			}
			// 파일안에 문자열 쓰기
			lw.flush();
			lw.close();
		}
		catch (Exception e) {
			e.printStackTrace();
		}

//		if(fileName.equals("literaltab_20150287")) {
//			for(LiteralTable l : literaltabList) {
//				for(int i = 0; i < l.literalList.size(); i++) {
//					System.out.println(l.literalList.get(i) + "	" + Integer.toHexString(l.locationList.get(i)).toUpperCase());
//				}
//			}
//		}
	}

	/**
	 * pass2 과정을 수행한다.
	 *   1) 분석된 내용을 바탕으로 object code를 생성하여 codeList에 저장.
	 */
	private void pass2() {
		// TODO Auto-generated method stub

		int objectcode;
		int opcode = 0;
		int address;
		char nixbpe = 0;
		Token tmp;

		for(TokenTable t : TokenList) {
			for(int t_index = 0; t_index < t.tokenList.size(); t_index++) {
				objectcode = 0;
				tmp = t.getToken(t_index);	//해당 section의 n번째 라인 토큰
				if(tmp.operator.equals("RESW")) {
					break;
				}

				if(tmp.operator.equals("WORD")) {
					tmp.byteSize = 3;
					tmp.objectCode = "000000";
					codeList.add(tmp.objectCode);
				}
				if(tmp.operator.equals("BYTE")) {
					codeList.add(tmp.objectCode);
				}
				if(tmp.operator.equals("END")) {
					codeList.add("05");
				}
				if(tmp.operator.equals("EXTREF")) {	//EXTREF처리, makeObjectCode 메소드에 extref 저장 용도
					t.makeObjectCode(t_index, opcode);
				}

				Boolean isIndex = false;	//operator가 instTable에 있는지 확인
				if(tmp.operator.charAt(0) == '+') {
					isIndex = instTable.instMap.containsKey(tmp.operator.substring(1));
				}
				else {
					isIndex = instTable.instMap.containsKey(tmp.operator);
				}

				if(isIndex != false) {
					address = 0;
					objectcode = 0;
					nixbpe = 0;
					opcode = 0;
					Instruction inst = null;
					if(tmp.operator.charAt(0) == '+') {
						inst = instTable.instMap.get(tmp.operator.substring(1));
					}
					else {
						inst = instTable.instMap.get(tmp.operator);
					}
					opcode = inst.opcode;	//opcode를 애초에 10진수로 저장했기 때문에 따로 변환할 필요가 없다.

					/////////////////////
					if(inst.format != 2) {
						if (tmp.operator.equals("RSUB")) {
							objectcode = opcode << 16 | nixbpe << 12 | 3 << 16; // ni=11로
							tmp.objectCode = Integer.toHexString(objectcode).toUpperCase();
							codeList.add(tmp.objectCode);
							continue;
						}
						if (tmp.operand[0].charAt(0) == '#') // immediate
							tmp.nixbpe = tmp.setFlag(TokenTable.iFlag, 1);

						else if (tmp.operand[0].charAt(0) == '@') // indirect
							tmp.nixbpe = tmp.setFlag(TokenTable.nFlag, 1);

						else
							tmp.nixbpe = tmp.setFlag(48, 1);	// simple

						tmp.nixbpe = tmp.setFlag(TokenTable.pFlag, 1);	//섹션컨트롤은 무조건 pc

						if (tmp.operand[0].charAt(0) == '#' || (tmp.operator.equals("RSUB"))) // pc부분 삭제
							tmp.nixbpe = (char) (tmp.nixbpe & (~(1 << 1)));

			/////////////////////////////////3,4형식일 때 objectCode만들기///////////////////////////////////
						address = t.makeObjectCode(t_index, opcode); //10진수
						objectcode = Integer.parseInt(tmp.objectCode, 16);
						//makeObjectCode에서 만든 뒷부분 주소(3자리)와 앞 3자리 objectCode를 합침
						tmp.objectCode = Integer.toHexString(objectcode | address).toUpperCase();
						codeList.add(tmp.objectCode);
					}

					else {
						opcode = opcode << 8;
						objectcode = objectcode | opcode;
						char reg_num1 = 0, reg_num2 = 0;//COMPR의 경우 레지스터가 2개
						char reg_part = 0;				//레지스터 연산 값 저장
						reg_num1 = (char) search_num_of_register(tmp.operand[0].charAt(0));//첫번째 레지스터 저장
						reg_part = (char) (reg_part | reg_num1);
						reg_part = (char) (reg_part << 4);	//첫번째 레지스터 이동
						if (tmp.operand[1] != null) // COMPR, 레지스터가 두개일 경우
						{
							reg_num2 = (char) search_num_of_register(tmp.operand[1].charAt(0));
							reg_part = (char) (reg_part | reg_num2); //첫번째 레지스터 값과 연산
						}

			/////////////////////////////2형식일 때 objectCode 만들기////////////////////////////////////
						objectcode = objectcode | reg_part;
						tmp.objectCode = Integer.toHexString(objectcode).toUpperCase();
						codeList.add(tmp.objectCode);
					}
				}
			}
		}
	}

	static int search_num_of_register(char c) {	// 레지스터 번호를 찾아주는 함수
		for (int t = 0; t < register_number.length; ++t)
		{
			if (register_number[t] == c) {
				return t;
			}
		}
		return -1;
	}

	/**
	 * 작성된 codeList를 출력형태에 맞게 출력한다.
	 * @param fileName : 저장되는 파일 이름
	 */
	private void printObjectCode(String fileName) {
		// TODO Auto-generated method stub
		Token extref = null;

		try {
			File fp = new File(fileName);
			String start = "000000"; // 항상 시작 주소
			BufferedWriter bw = new BufferedWriter(new FileWriter(fp));

			int tl_index = 0; //TokenList Index

			////////////////////////////0번째 섹션 출력 시작/////////////////////////////////

			TokenTable nList = TokenList.get(tl_index++);	//nList = 0번째 섹션의 토큰리스트
			bw.write('H');
			bw.write(String.format("%-6s", nList.getToken(0).label));
			bw.write(start);
			bw.write(String.format("%06X\n", Integer.parseInt(section_len[0], 16))); //String을 16진수로 변환해서 출력
			/////H record 출력 끝/////

			int line_len = 0;		//T record 줄 길이 계산용
			int start_address = 0;			//T record 시작 주소 저장용
			for(int t_index = 0; t_index < nList.tokenList.size(); t_index++) {
				Token tmp = nList.getToken(t_index);

				if(tmp.operator.equals("EXTDEF")) {
					bw.write('D');
					for(int i = 0; i < 3; i++) {
						if(tmp.operand[i] != null) {
							bw.write(tmp.operand[i]);
							int idx = nList.symTab.symbolList.indexOf(tmp.operand[i]);//operand가 심볼리스트 몇번째인지
							int loc = nList.symTab.locationList.get(idx);//몇번짼지 알았으면 로케이션리스트에서 갖고오기
							bw.write(String.format("%06X", loc));//16진수로 출력
						}
					}
					bw.newLine();
					continue;
				}
				/////D record 출력 끝/////

				if(tmp.operator.equals("EXTREF")) {
					bw.write('R');
					for(int i = 0; i < 3; i++)
						if(tmp.operand[i] != null)
							bw.write(String.format("%-6s", tmp.operand[i]));
					bw.newLine();
					continue;
				}
				/////R record 출력 끝/////

				if(line_len + tmp.byteSize <= 0X1D) { //줄 길이가 꽉 찰 때 까지 증가
					line_len += tmp.byteSize;
				}
				else {
					bw.write('T');	//줄 길이가 꽉 차면 출력 시작
					bw.write(String.format("%06X", nList.getToken(start_address).location));//T record 출력 시작 주소
					bw.write(String.format("%02X", line_len));//T record 줄 길이 출력

					for(int t_print = 0; t_print < t_index; t_print++) {
						Token t = nList.getToken(t_print);
						Boolean t_idx;
						Instruction inst = null;

						if(t.operator.charAt(0) == '+') { // + 빼고 operator 체크
							t_idx = nList.instTab.instMap.containsKey(t.operator.substring(1));
							inst = instTable.instMap.get(t.operator.substring(1));
						}
						else {
							t_idx = nList.instTab.instMap.containsKey(t.operator);
							inst = instTable.instMap.get(t.operator);
						}
						if(t_idx == false)				// instMap에 없는 operator면 넘겨버리기
							continue;

						if(t.operator.charAt(0) == '+')
							bw.write(String.format("%08X", Integer.parseInt(t.objectCode, 16)));
						else if(inst.format == 3)
							bw.write(String.format("%06X", Integer.parseInt(t.objectCode, 16)));
						else if(inst.format == 2)
							bw.write(String.format("%04X", Integer.parseInt(t.objectCode, 16)));
					}
					bw.newLine();
					start_address = t_index;
					line_len = 0;
				}

				if(tmp.operator.equals("RESW")) {	//section이 끝날 때 강제 출력
					bw.write('T');
					bw.write(String.format("%06X", nList.getToken(start_address).location));//T record 출력 시작 주소
					bw.write(String.format("%02X", line_len));//T record 줄 길이 출력

					for(int t_print = start_address; t_print < t_index; t_print++) {
						Token t = nList.getToken(t_print);
						Boolean t_idx;
						Instruction inst = null;

						if(t.operator.charAt(0) == '+') { // + 빼고 operator 체크
							t_idx = nList.instTab.instMap.containsKey(t.operator.substring(1));
							inst = instTable.instMap.get(t.operator.substring(1));
						}
						else {
							t_idx = nList.instTab.instMap.containsKey(t.operator);
							inst = instTable.instMap.get(t.operator);
						}
						if(t_idx == false)				// instMap에 없는 operator면 넘겨버리기
							continue;

						if(t.operator.charAt(0) == '+')	// 형식에 맞게 출력 서식을 정해준다
							bw.write(String.format("%08X", Integer.parseInt(t.objectCode, 16)));
						else if(inst.format == 3)
							bw.write(String.format("%06X", Integer.parseInt(t.objectCode, 16)));
						else if(inst.format == 2)
							bw.write(String.format("%04X", Integer.parseInt(t.objectCode, 16)));
					}
					bw.newLine();
					if(!(nList.literalTab.literalList.isEmpty())) {	//섹션이 끝날 때 literal 추가된게 있는지 확인
						bw.write('T');
						bw.write(String.format("%06X", nList.tokenList.get(19).location-3));
						bw.write(String.format("%02X", 3));
						String s = nList.literalTab.literalList.get(0);
						bw.write(String.format("%02X", (int)(s.charAt(0))));
						bw.write(String.format("%02X", (int)(s.charAt(1))));
						bw.write(String.format("%02X", (int)(s.charAt(2))));
						bw.newLine();
						break;
					}
				}
			}
			/////T record 출력 끝/////

			int line_byte = 1;
			for(int m_index = 2; m_index < nList.tokenList.size(); m_index++) {
				Token tmp = nList.getToken(m_index);

				if(tmp.operator.equals("EXTREF")) {
					extref = tmp;
					continue;
				}

				if(tmp.operator.equals("RESW")) {
					bw.write('E');
					bw.write(start);
					break;
				}
				//operand에 EXTREF의 심볼이 있는걸 찾아서 쓰기
				//바이트 크기 기준으로 메모리 위치를 나타내기 때문에 objectCode단위로 증가하면서 어느 위치에 값을 변경할 것인지 찾아감
				if(tmp.operand[0].equals(extref.operand[0]) || tmp.operand[0].equals(extref.operand[1])) {
					bw.write('M');
					bw.write(String.format("%06X", line_byte));
					line_byte += tmp.byteSize;
					bw.write("05+");
					bw.write(tmp.operand[0]);
					bw.newLine();

				}
				else
					line_byte += tmp.byteSize;

			}
			/////M record 출력 끝/////

			bw.newLine();
			bw.newLine();

			///////////////////////////1번째 섹션 출력 시작/////////////////////////

			TokenTable nList_1 = TokenList.get(tl_index++);	//nList = 0번째 섹션의 토큰리스트
			bw.write('H');
			bw.write(String.format("%-6s", nList_1.getToken(1).label));
			bw.write(start);
			bw.write(String.format("%06X\n", Integer.parseInt(section_len[1], 16))); //String을 16진수로 변환해서 출력
			/////H record 출력 끝/////

			int line_len_1 = 0;		//T record 줄 길이 계산용
			int start_address_1 = 0;			//T record 시작 주소 저장용
			for(int t_index = 0; t_index < nList_1.tokenList.size(); t_index++) {
				Token tmp = nList_1.getToken(t_index);

				if(tmp.operator.equals("EXTDEF")) {
					bw.write('D');
					for(int i = 0; i < 3; i++) {
						if(tmp.operand[i] != null) {
							bw.write(tmp.operand[i]);
							int idx = nList_1.symTab.symbolList.indexOf(tmp.operand[i]);//operand가 심볼리스트 몇번째인지
							int loc = nList_1.symTab.locationList.get(idx);//몇번짼지 알았으면 로케이션리스트에서 갖고오기
							bw.write(String.format("%06X", loc));//16진수로 출력
						}
					}
					bw.newLine();
					continue;
				}
				/////D record 출력 끝/////

				if(tmp.operator.equals("EXTREF")) {
					bw.write('R');
					for(int i = 0; i < 3; i++)
						if(tmp.operand[i] != null)
							bw.write(String.format("%-6s", tmp.operand[i]));
					bw.newLine();
					continue;
				}
				/////R record 출력 끝/////

				if(line_len_1 + tmp.byteSize <= 0X1D) { //줄 길이가 꽉 찰 때 까지 증가
					line_len_1 += tmp.byteSize;
				}
				else {
					bw.write('T');	//줄 길이가 꽉 차면 출력 시작
					bw.write(String.format("%06X", nList_1.getToken(start_address_1).location));//T record 출력 시작 주소
					bw.write(String.format("%02X", line_len_1));//T record 줄 길이 출력

					for(int t_print = 0; t_print < t_index; t_print++) {
						Token t = nList_1.getToken(t_print);
						Boolean t_idx;
						Instruction inst = null;

						if(t.operator.charAt(0) == '+') { // + 빼고 operator 체크
							t_idx = nList_1.instTab.instMap.containsKey(t.operator.substring(1));
							inst = instTable.instMap.get(t.operator.substring(1));
						}
						else {
							t_idx = nList_1.instTab.instMap.containsKey(t.operator);
							inst = instTable.instMap.get(t.operator);
						}
						if(t_idx == false)				// instMap에 없는 operator면 넘겨버리기
							continue;

						if(t.operator.charAt(0) == '+')
							bw.write(String.format("%08X", Integer.parseInt(t.objectCode, 16)));
						else if(inst.format == 3)
							bw.write(String.format("%06X", Integer.parseInt(t.objectCode, 16)));
						else if(inst.format == 2)
							bw.write(String.format("%04X", Integer.parseInt(t.objectCode, 16)));
					}
					bw.newLine();
					start_address_1 = t_index;
					line_len_1 = 0;
				}

				if(tmp.operator.equals("CSECT")) {	//section이 끝날 때 강제 출력
					bw.write('T');
					bw.write(String.format("%06X", nList_1.getToken(start_address_1).location));//T record 출력 시작 주소
					bw.write(String.format("%02X", line_len_1+3));//T record 줄 길이 출력

					for(int t_print = start_address_1; t_print < t_index; t_print++) {
						Token t = nList_1.getToken(t_print);
						Boolean t_idx = false;
						Instruction inst = null;

						if(t.operator.charAt(0) == '+') { // + 빼고 operator 체크
							t_idx = nList_1.instTab.instMap.containsKey(t.operator.substring(1));
							inst = instTable.instMap.get(t.operator.substring(1));
						}
						else if(t.operator.equals("BYTE") || t.operator.equals("WORD")) {
							bw.write(t.objectCode);
						}
						else {
							t_idx = nList_1.instTab.instMap.containsKey(t.operator);
							inst = instTable.instMap.get(t.operator);
						}
						if(t_idx == false)				// instMap에 없는 operator면 넘겨버리기
							continue;

						if(t.operator.charAt(0) == '+')	// 형식에 맞게 출력 서식을 정해준다
							bw.write(String.format("%08X", Integer.parseInt(t.objectCode, 16)));
						else if(inst.format == 3)
							bw.write(String.format("%06X", Integer.parseInt(t.objectCode, 16)));
						else if(inst.format == 2)
							bw.write(String.format("%04X", Integer.parseInt(t.objectCode, 16)));
					}
					break;
				}
			}
			bw.newLine();
			/////T record 출력 끝/////
			int line_byte_1 = 1;
			for(int m_index = 0; m_index < nList_1.tokenList.size(); m_index++) {
				Token tmp = nList_1.getToken(m_index);

				if(tmp.operator.equals("EXTREF")) {
					extref = tmp;
					continue;
				}

				if(tmp.operator.equals("CSECT")) {
					bw.write('E');
					break;
				}
				//operand에 EXTREF의 심볼이 있는걸 찾아서 쓰기
				//바이트 크기 기준으로 메모리 위치를 나타내기 때문에 objectCode단위로 증가하면서 어느 위치에 값을 변경할 것인지 찾아감
				if(tmp.operator.equals("RSUB")) {
					line_byte_1 += 2;
					continue;
				}

				if(tmp.operand[0].equals(extref.operand[0]) || tmp.operand[0].equals(extref.operand[1])) {
					bw.write('M');
					bw.write(String.format("%06X", line_byte_1));
					line_byte_1 += tmp.byteSize;
					bw.write("05+");
					bw.write(tmp.operand[0]);
					bw.newLine();

				}
				else if(tmp.operator.equals("WORD")) {
					bw.write('M');
					bw.write(String.format("%06X", line_byte_1));
					bw.write("06+");
					bw.write(extref.operand[2]);
					bw.newLine();
					bw.write('M');
					bw.write(String.format("%06X", line_byte_1));
					bw.write("06-");
					bw.write(extref.operand[0]);
					bw.newLine();
				}
				else
					line_byte_1 += tmp.byteSize;
			}
			/////M record 출력 끝/////
			bw.newLine();
			bw.newLine();

			////////////////////////2번째 섹션 출력 시작///////////////////////////////


			TokenTable nList_2 = TokenList.get(2);	//nList = 0번째 섹션의 토큰리스트
			bw.write('H');
			bw.write(String.format("%-6s", nList_2.getToken(1).label));
			bw.write(start);
			bw.write(String.format("%06X\n", Integer.parseInt(section_len[2], 16))); //String을 16진수로 변환해서 출력
			/////H record 출력 끝/////

			int line_len_2 = 0;		//T record 줄 길이 계산용
			int start_address_2 = 0;			//T record 시작 주소 저장용
			for(int t_index = 0; t_index < nList_2.tokenList.size(); t_index++) {
				Token tmp = nList_2.getToken(t_index);

				if(tmp.operator.equals("EXTDEF")) {
					bw.write('D');
					for(int i = 0; i < 3; i++) {
						if(tmp.operand[i] != null) {
							bw.write(tmp.operand[i]);
							int idx = nList_2.symTab.symbolList.indexOf(tmp.operand[i]);//operand가 심볼리스트 몇번째인지
							int loc = nList_2.symTab.locationList.get(idx);//몇번짼지 알았으면 로케이션리스트에서 갖고오기
							bw.write(String.format("%06X", loc));//16진수로 출력
						}
					}
					bw.newLine();
					continue;
				}
				/////D record 출력 끝/////

				if(tmp.operator.equals("EXTREF")) {
					bw.write('R');
					for(int i = 0; i < 3; i++)
						if(tmp.operand[i] != null)
							bw.write(String.format("%-6s", tmp.operand[i]));
					bw.newLine();
					continue;
				}
				/////R record 출력 끝/////

				if(line_len_2 + tmp.byteSize <= 0X1D) { //줄 길이가 꽉 찰 때 까지 증가
					line_len_2 += tmp.byteSize;
				}
				else {
					bw.write('T');	//줄 길이가 꽉 차면 출력 시작
					bw.write(String.format("%06X", nList_2.getToken(start_address_2).location));//T record 출력 시작 주소
					bw.write(String.format("%02X", line_len_2));//T record 줄 길이 출력

					for(int t_print = 0; t_print < t_index; t_print++) {
						Token t = nList_2.getToken(t_print);
						Boolean t_idx;
						Instruction inst = null;

						if(t.operator.charAt(0) == '+') { // + 빼고 operator 체크
							t_idx = nList_2.instTab.instMap.containsKey(t.operator.substring(1));
							inst = instTable.instMap.get(t.operator.substring(1));
						}
						else {
							t_idx = nList_2.instTab.instMap.containsKey(t.operator);
							inst = instTable.instMap.get(t.operator);
						}
						if(t_idx == false)				// instMap에 없는 operator면 넘겨버리기
							continue;

						if(t.operator.charAt(0) == '+')
							bw.write(String.format("%08X", Integer.parseInt(t.objectCode, 16)));
						else if(inst.format == 3)
							bw.write(String.format("%06X", Integer.parseInt(t.objectCode, 16)));
						else if(inst.format == 2)
							bw.write(String.format("%04X", Integer.parseInt(t.objectCode, 16)));
					}
					bw.newLine();
					start_address_2 = t_index;
					line_len_2 = 0;
				}

				if(tmp.operator.equals("END")) {	//section이 끝날 때 강제 출력
					bw.write('T');
					bw.write(String.format("%06X", nList_2.getToken(start_address_2).location));//T record 출력 시작 주소

					bw.write(String.format("%02X", line_len_2+1));//T record 줄 길이 출력

					for(int t_print = start_address_2; t_print < t_index; t_print++) {
						Token t = nList_2.getToken(t_print);
						Boolean t_idx;
						Instruction inst = null;

						if(t.operator.charAt(0) == '+') { // + 빼고 operator 체크
							t_idx = nList_2.instTab.instMap.containsKey(t.operator.substring(1));
							inst = instTable.instMap.get(t.operator.substring(1));
						}
						else {
							t_idx = nList_2.instTab.instMap.containsKey(t.operator);
							inst = instTable.instMap.get(t.operator);
						}
						if(t_idx == false)				// instMap에 없는 operator면 넘겨버리기
							continue;

						if(t.operator.charAt(0) == '+')	// 형식에 맞게 출력 서식을 정해준다
							bw.write(String.format("%08X", Integer.parseInt(t.objectCode, 16)));
						else if(inst.format == 3)
							bw.write(String.format("%06X", Integer.parseInt(t.objectCode, 16)));
						else if(inst.format == 2)
							bw.write(String.format("%04X", Integer.parseInt(t.objectCode, 16)));
					}
					if(!(nList.literalTab.literalList.isEmpty()))
						bw.write(nList_2.literalTab.literalList.get(0));
					break;
				}
			}
			bw.newLine();
			/////T record 출력 끝/////
			int line_byte_2 = 1;
			for(int m_index = 0; m_index < nList_2.tokenList.size(); m_index++) {
				Token tmp = nList_2.getToken(m_index);

				if(tmp.operator.equals("EXTREF")) {
					extref = tmp;
					continue;
				}
				if(tmp.operator.equals("RSUB")) {
					continue;
				}

				if(tmp.operator.equals("END")) {
					bw.write('E');
					break;
				}
				//operand에 EXTREF의 심볼이 있는걸 찾아서 쓰기
				//바이트 크기 기준으로 메모리 위치를 나타내기 때문에 objectCode단위로 증가하면서 어느 위치에 값을 변경할 것인지 찾아감
				if(tmp.operand[0].equals(extref.operand[0]) || tmp.operand[0].equals(extref.operand[1])) {
					bw.write('M');
					bw.write(String.format("%06X", line_byte_2));
					line_byte_2 += tmp.byteSize;
					bw.write("05+");
					bw.write(tmp.operand[0]);
					bw.newLine();

				}
				else
					line_byte_2 += tmp.byteSize;

			}
			/////M record 출력 끝/////
			bw.newLine();
			bw.flush();
			bw.close();
		}
		catch (Exception e) {
			e.printStackTrace();
		}
	}
}
